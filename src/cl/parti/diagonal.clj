(ns ^{:doc "

The main image builder, responsible for generating the tile pattern.

To work well the end result must be attractive, but detailed.  The algorithm
here grew through iterative improvement and experimentation, but in
retrospect the following properties are important:

- **Diagonal symmetry.**  A completely random image feels 'messy' and is
  difficult to remember when making comparisons.

- **Structure over a range of scales.**  The largest scales give the image a
  particular character; smaller scales help carry more information in a
  detailed comparison.

- **Irregularity.**  When a 'structured' design is used, the fact that there
  is regularity somehow becomes more important than the details of the
  structure.  This is hard to explain, but easy to see in images from the
  `fourier` builder, where all the images are 'tartan-like' and become easy
  to confuse.

- **Tiles.**  These serve two purposes.  First, they allow more accurate
  comparison in the variation of tone between images (whether an area of
  similar colours is flat or varying).  Second, they give the impression
  of a 'computer generated', qualitative object (something like a barcode).

- **Saturated colours.**  These give a 'jewel-like' feel and help separate
  the image from a variety of contexts.

More than all the above, the end result must 'feel right'.  This is an
aristic, emotional choice, that is hard to define but critical in
attracting the attention of users.  Without this, a hex string is a
better format for the hash.

Images are generated by selecting random rectangles and modifying the contents.
The working representation is a square array of integer values.  These are
normalised to floats in the range (-1 1) at the end of the process; the
render function (`cl.parti.output`) will later convert these values to colours.

"
      :author "andrew@acooke.org"}
  cl.parti.diagonal
  (:use (cl.parti random utils))
  (:use clojure.math.numeric-tower))


;; ## Generate random parameters

;(defn- int16-symmetric
;  "Select a random integer from [-n n]."
;  [n state]
;  (let [[r state] (rand-int16 (inc (* 2 n)) state)]
;    [(- r n) state]))

(defn- centre-distance
  "One plus the number of pixels between the given block (starting at `x`,
  length `dx`) and the central pixel(s), when placed in a line of length `n`.
  A block that overlaps the centre has distance 0."
  [n]
  (let [nlo (int (/ (dec n) 2))
        nhi (int (/ n 2))]
    (fn [x1 dx]
      (let [x2 (dec (+ x1 dx))]
        (cond
          (and (>= x2 nlo) (<= x1 nhi)) 0
          (< x2 nlo) (- nlo x2)
          (> x1 nhi) (- x1 nhi)
          :else (assert nil (str x1 " " x2 " " n " " nlo " " nhi)))))))

(defn manhattan
  "The 'Manhattan' distance (dx + dy) between a block and the mosaic centre."
  [n]
  (let [d (centre-distance n)]
    (fn [[dx dy x y]]
      (+ (d x dx) (d y dy)))))

(defn manhattan-delta
  "Calculate a 'delta' - the amount to shift the selected rectangle - by
  selecting a random value from within a range defined by the distance
  from the centre of the mosaic.

  This fixes a weakness in an earlier scheme, which selected randomly
  from a uniform range for all rectangles.  That gave images that varied
  most in the centre of the image (where, on average, most rectangles
  overlap).  By increasing the range towards the edge of the mosaic we
  counter-balance that statistical tendency and so get a more even
  distribution of 'noise' across the image, reducing the number of
  collisions (ie. increasing the effective bit length)."
  [n]
  (let [m (manhattan n)]
    (fn [location state]
      (let [d (inc (m location))]
        (rand-bits-symmetric d state)))))

;(defn manhattan-delta
;  [n]
;  (let [m (manhattan n)]
;    (fn [location state]
;      (let [d (inc (m location))
;            [delta state] (rand-sign state)]
;        [(* d delta) state]))))

(defn- parameters
  "Construct a lazy sequence of random values, taken from the functions
  above.  This provides the data for an arbitrary number of transformations.

  `state` is available at each step so that the latest state can be
  returned to the called once the desired number of transformations have
  been made."
  [gen-location gen-delta n state]
  (lazy-seq
    (let [[location state] (gen-location n state)
          [delta state] (gen-delta location state)]
      (cons [delta location state]
        (parameters gen-location gen-delta n state)))))

(defn- rand-2
  "Generate two values, `side` and `offset`, selecting the first from a uniform
  distribution in the range [0 n) and the second in the range [0 (n-side)).
  This means that `side` and `side+offset` are both in [0 n).

  The value of `side` is then incremented by 1 to give a non-zero value."
  [n state]
  (let [[side state] (rand-bits n state)
        [offset state] (rand-bits (- n side) state)]
    [[(inc side) offset] state]))

(defn rand-4
  "Generate four values - the sides and offset of a rectangle - so that
  the rectangle lies at least partly in the lower triangle (including the
  diagonal).

  Details / ranges are as for `rand-2`."
  [n state]
  (let [[[dx x] state] (rand-2 n state)
        [[dy y] state] (rand-2 n state)]
    (if (> x (+ y dy)) (recur n state) [[dx dy x y] state])))

;; ## The transformation

(def ^:private
  ^{:doc "Scale for converting for normalisation.  Smaller values emphasise
  middle ranges in the data.

  A value of 0.3 gave a central bias (for square) of 60:1 (seen using the
  histogram from `cl.parti.dump`); 0.1 went the other way 1:60; 0.2 was
  reasonably flat at 1:2; using 0.23 makes the results less contrasty."}
  NORM 0.23)

(defn shift-rectangle
  "Add `delta` to the rectangle defined by the random parameters.

  The latest `state` is made available for use by the caller."
  [[n rows] [delta [dx dy x y] state]]
  (let [xys (for [i (range dx) j (range dy)] [(+ x i) (+ y j)])
        delta #(+ delta %)]
    [n (reduce #(vapply-2 delta %1 %2) rows xys) state]))

(defn repeated-transform
  "Pull all the above together - generate a sequence of random parameters
  and then iterate over them, repeatedly transforming the mosaic.

  Returns the final mosaic (2D nested sequences of un-normalized integers)
  and the latest state."
  [gen-location gen-delta transformer n count state]
  (let [rows (vec (repeat n (vec (repeat n 0))))
        [n rows state]
        (reduce transformer [n rows]
          (take count
            (parameters gen-location gen-delta n state)))]
    [rows state]))

(defn reflect
  "Reflect the lower triangle to the upper.  This allows the `rectangle`
  builder to generate an initial, asymmetric pattern."
  [n rows]
  (for [y (range n)]
    (for [x (range n)]
      (let [[x y] (if (> x y) [y x] [x y])]
        (nth-2 rows [x y])))))

(defn rectangle
  "The rectangle builder function."
  [n]
  (fn [state]
    (let [[rows state]
          (repeated-transform
            rand-4 (manhattan-delta n) shift-rectangle n (expt n 2) state)
          norm (* NORM (expt n 1.5))]
      [norm (reflect n rows) state])))

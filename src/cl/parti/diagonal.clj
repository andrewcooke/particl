(ns ^{:doc "

The main image builder, responsible for generating the tile pattern.

To work well the end result must be attractive, but detailed.  The algorithm
here grew through iterative improvement and experimentation, but in
retrospect the following properties are important:

- **Diagonal symmetry.**  A completely random image feels 'messy' and is
  difficult to remember when making comparisons.

- **Structure over a range of scales.**  The largest scales give the image a
  particular character; smaller scales help carry more information in a
  detailed comparison.

- **Irregularity.**  When a 'structured' design is used, the fact that there
  is regularity somehow becomes more important than the details of the
  structure.  This is hard to explain, but easy to see in images from the
  `fourier` builder, where all the images are 'tartan-like' and become easy
  to confuse.

- **Tiles.**  These serve two purposes.  First, they allow more accurate
  comparison in the variation of tone between images (whether an area of
  similar colours is flat or varying).  Second, they give the impression
  of a 'computer generated', qualitative object (something like a barcode).

- **Saturated colours.**  These give a 'jewel-like' feel and help separate
  the image from a variety of contexts.

More than all the above, the end result must 'feel right'.  This is an
aristic, emotional choice, that is hard to define but critical in
attracting the attention of users.  Without this, a hex string is a
better format for the hash.

Images are generated by selecting random rectangles and modifying the contents.
The working representation is a square array of integer values.  These are
normalised to floats in the range (-1 1) at the end of the process; the
render function (`cl.parti.output`) will later convert these values to colours.

"
      :author "andrew@acooke.org"}
  cl.parti.diagonal
  (:use (cl.parti random))
  (:use clojure.math.numeric-tower))


;; ## Generate random parameters

(def ^:private
  ^{:doc "Range over which values can be shifted in a single transformation."}
  DELTA 127)

(defn- rand-range
  "Generate a uniformly distributed pseudo-random integer in the range
  `[-DELTA DELTA]`.

  This value is used to give the strength of the shift applied to the
  randomly selected square."
  [state]
  (let [[r state] (rand-byte (inc (* 2 DELTA)) state)]
    [(- r DELTA) state]))

(defn- parameters
  "Construct a lazy sequence of random values, taken from the functions
  above.  This provides the data for an arbitrary number of transformations.

  `state` is available at each step so that the latest state can be
  returned to the called once the desired number of transformations have
  been made."
  [gen-location gen-delta n state]
  (lazy-seq
    (let [[location state] (gen-location n state)
          [delta state] (gen-delta state)]
      (cons [delta location state]
        (parameters gen-location gen-delta n state)))))

(defn- rand-2
  "Generate two values, `side` and `offset`, selecting the first from a uniform
  distribution in the range [0 n) and the second in the range [0 (n-side)).
  This means that `side` and `side+offset` are both in [0 n).

  The value of `side` is then incremented by 1 to give a non-zero square,
  which `offset` will position on the diagonal."
  [n state]
  (let [[side state] (rand-byte n state)
        [offset state] (rand-byte (- n side) state)]
    [[(inc side) offset] state]))

(defn rand-4
  "Generate four values - the sides and offset of a rectangle - so that
  the rectangle lies at least partly in the lower triangle (including the
  diagonal).

  Details / ranges are as for `rand-square`."
  [n state]
    (let [[[dx x] state] (rand-2 n state)
          [[dy y] state] (rand-2 n state)]
      ; major bug here with (> y x)
      ; x increases down, y increases to right; important triangle is
      ; bottom-left.
      (if (> y (+ x dx)) (recur n state) [[dx dy x y] state])))

;; ## The transformation

(def ^:private
  ^{:doc "Scale for converting for normalisation.  Smaller values emphasise
  middle ranges in the data.

  A value of 0.3 gave a central bias (for square) of 60:1 (seen using the
  histogram from `cl.parti.dump`); 0.1 went the other way 1:60; 0.2 was
  reasonably flat at 1:2; using 0.23 makes the results less contrasty."}
  NORM 0.23)

(defn apply-2
  "Apply function `f` to the value in the 2D nested sequences `rows` at
  (`x`,`y`)."
  [f rows [x y]]
  (let [row (rows x)
        val (f (row y))]
    (assoc rows x (assoc row y val))))

(defn shift-rectangle
  "Add `delta` to the rectangle defined by the random parameters.

  The latest `state` is made available for use by the caller."
  [[n rows] [delta [dx dy x y] state]]
  (let [xys (for [i (range dx) j (range dy)] [(+ x i) (+ y j)])
        delta #(+ delta %)]
    [n (reduce #(apply-2 delta %1 %2) rows xys) state]))

(defn repeated-transform
  "Pull all the above together - generate a sequence of random parameters
  and then iterate over them, repeatedly transforming the mosaic.

  Returns the final mosaic (2D nested sequences of un-normalized integers)
  and the latest state."
  [gen-location gen-delta transformer n count state]
  (let [rows (vec (repeat n (vec (repeat n 0))))
        [n rows state]
        (reduce transformer [n rows]
          (take count
            (parameters gen-location gen-delta n state)))]
    [rows state]))

(defn reflect
  "Reflect the lower triangle to the upper.  This allows the `rectangle`
  builder to generate an initial, asymmetric pattern."
  [n rows]
  (for [x (range n)]
    (for [y (range n)]
      (let [[x y] (if (> y x) [y x] [x y])]
        (nth (nth rows x) y)))))

(defn rectangle
  "The rectangle builder function."
  [n]
  (fn [state]
    (let [[rows state]
          (repeated-transform rand-4 rand-range shift-rectangle n (expt n 2) state)
          norm (* NORM DELTA (expt n 0.8))]
      [norm (reflect n rows) state])))


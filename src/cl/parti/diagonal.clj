(ns ^{:doc "

The main image builders, responsible for generating the tile pattern.

To work well the end result must be attractive, but detailed.  The algorithm
here grew through iterative improvement and experimentation, but in
retrospect the following properties are important:

- **Diagonal symmetry.**  A completely random image feels 'messy' and is
  difficult to remember when making comparisons.

- **Structure over a range of scales.**  The largest scales give the image a
  particular character; smaller scales help carry more information in a
  detailed comparison.

- **Irregularity.** A 'structured' design - the idea that the image is
  structured becomes more important than the details of the structure.
  This is hard to explain, but easy to see in images from the `fourier`
  builder, where all the images are 'tartan-like' and become easy to
  confuse.

- **Tiles.**  These serve two purposes.  First, they allow more accurate
  comparison in the variation of tone between images (whether an area of
  similar colours is flat or varying).  Second, they give the impression
  of a 'computer generated', qualitative object (something like a barcode).

- **Saturated colours.**  These give a 'jewel-like' feel and help separate
  the image from a variety of contexts.

More than all the above, the end result must 'feel right'.  This is an
aristic, emotional choice, that is hard to define but critical in
attracting the attention of users.  Without this, a hex string is a
better format for the hash.

Images are generated by selecting random squares and modifying the contents.
The working representation is a square array of integer values.  These are
normalised to floats in the range (-1 1) at the end of the process; the
render function (`cl.parti.output`) will later convert these values to colours.

"
      :author "andrew@acooke.org"}
  cl.parti.diagonal
  (:use (cl.parti random mosaic))
  (:use clojure.math.numeric-tower))


;; ## Generate random parameters
;;
;; There are two, very similar, approaches here.  One, 'square', generates
;; and transforms squares lying on the mosaic diagonal.  The other, 'rectangle',
;; selects rectangles at random, uses only those that lie (at least
;; partially) in the lower triangle, and then enforces symmetry by mirroring
;; that triangle.

(def ^:private
  ^{:doc "Range over which values can be shifted in a single transformation."}
  DELTA 127)

(defn- rand-square
  "Generate two values, `side` and `offset`, selecting the first from a uniform
  distribution in the range [0 n) and the second in the range [0 (n-side)).
  This means that `side` and `side+offset` are both in [0 n).

  The value of `side` is then incremented by 1 to give a non-zero square,
  which `offset` will position on the diagonal."
  [n state]
  (let [[side state] (rand-byte n state)
        [offset state] (rand-byte (- n side) state)]
    [[(inc side) offset] state]))

(defn- rand-rectangle
  "Generate four values - the sides and offset of a rectangle - so that
  the rectangle lies at least partly in the lower triangle (including the
  diagonal).

  Details / ranges are as for `rand-square`."
  [n state]
    (let [[[dx x] state] (rand-square n state)
          [[dy y] state] (rand-square n state)]
      (if (> y x) (recur n state) [[dx dy x y] state])))

(defn- rand-range
  "Generate a uniformly distributed pseudo-random integer in the range
  [-DELTA DELTA].

  This value is used to give the strength of the shift applied to the
  randomly selected square."
  [state]
  (let [[r state] (rand-byte (inc (* 2 DELTA)) state)]
    [(- r DELTA) state]))

(defn- parameters
  "Construct a lazy sequence of random values, taken from the functions
  above.  This provides the data for an arbitrary number of transformations.

  `state` is available at each step so that the latest state can be
  returned to the called once the desired number of transformations have
  been made."
  [generator n state]
  (lazy-seq
    (let [[location state] (generator n state)
          [delta state] (rand-range state)]
      (cons [delta location state] (parameters generator n state)))))

;; ## The transformations

(def ^:private
  ^{:doc "Scale for converting for normalisation.  Smaller values emphasise
  middle ranges in the data.

  A value of 0.3 gave a central bias (for square) of 60:1 (seen using the
  histogram from `cl.parti.dump`); 0.1 went the other way 1:60; 0.2 was
  reasonably flat at 1:2; using 0.23 makes the results less contrasty."}
  NORM 0.23)

(defn apply-2
  "Apply function `f` to the value in the 2D nested sequences `rows` at
  (`x`,`y`)."
  [f rows [x y]]
  (let [row (rows x)
        val (f (row y))]
    (assoc rows x (assoc row y val))))

(defn- transform-square
  "Add `delta` to the square defined by `side` and `offset`.

  The latest `state` is made available for use by the caller."
  [[n rows] [delta [side offset] state]]
  (let [xys (for [x (range side) y (range side)] [(+ x offset) (+ y offset)])
        delta #(+ delta %)]
    [n (reduce #(apply-2 delta %1 %2) rows xys) state]))

(defn- transform-rectangle
  "As `transform-square`, but using the extended parameters for an
  unconstrained rectangle."
  [[n rows] [delta [dx dy x y] state]]
  (let [xys (for [i (range dx) j (range dy)] [(+ x i) (+ y j)])
        delta #(+ delta %)]
    [n (reduce #(apply-2 delta %1 %2) rows xys) state]))

(defn- repeated-transform
  "Pull all the above together - generate a sequence of random parameters
  and then iterate over them, repeatedly transforming the mosaic.

  Returns the final mosaic (2D nested sequences of un-normalized integers)
  and the latest state."
  [generator transformer n count state]
  (let [rows (vec (repeat n (vec (repeat n 0))))
        [n rows state]
        (reduce transformer [n rows]
          (take count
            (parameters generator n state)))]
    [rows state]))

(defn square
  "The square render function.  The output from `repeated-transform` is
  normalized to the range (-1 1).

  Some parameters are inferred from the mosaic size, `n`, to give a
  consistent appearance across a range of sizes.

  All calculations before normalisation are exact (integer) values.  This
  should support alternative implementations (repeated application of
  transformations based on random *real* values could have been sensitive
  to small differences in floating point calculations)."
  [n]
  (fn [state]
    (let [[rows state]
          (repeated-transform rand-square transform-square n (expt n 2) state)
          norm (* NORM DELTA (expt n 0.8))]
      [norm rows state])))

(defn- reflect
  "Reflect the lower triangle to the upper.  This allows the 'reactangle'
  render to generate an initial, asymmetric pattern."
  [n rows]
  (for [x (range n)]
    (for [y (range n)]
      (let [[x y] (if (> y x) [y x] [x y])]
        (nth (nth rows x) y)))))

(defn rectangle
  "The rectangle render function."
  [n]
  (fn [state]
    (let [[rows state]
          (repeated-transform rand-rectangle transform-rectangle n (expt n 2) state)
          norm (* NORM DELTA (expt n 0.8))]
      [norm (reflect n rows) state])))


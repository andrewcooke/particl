(ns ^{:doc "

The main image builder, responsible for generating the image structure.

To work well the end result must be attractive, but detailed.  The algorithm
here grew through iterative improvement and experimentation, but in
retrospect the following properties are important:

- **Diagonal symmetry.**  A completely random image feels 'messy' and is
  difficult to remember when making comparisons.

- **Structure over a range of scales.**  The largest scales give the image a
  particular character; smaller scales help carry more information in a
  detailed comparison.

- **Irregularity.** A 'structured' design - the idea that the image is
  structured becomes more important than the details of the structure.
  This is hard to explain, but easy to see in images from the `fourier`
  builder, where all the images are 'tartan-like' and become easy to
  confuse.

- **Tiles.**  This serves two purposes.  First, it allows more accurate
  comparison in the variation of tone between images (it clarifies whether
  an area of similar colour is flat or varying).  Second, it gives the
  impression of a 'computer generated', qualitative object.

- **Saturated colours.**  These give a 'jewel-like' feel and help separate
  the image from a variety of contexts.

More than all the above, the end result must 'feel right'.  This is an
aristic, emotional choice, that is hard to define but critical in
attracting the attention of users.  Without this, a hex string is a
better format for the hash.

Images are generated by selecting random squares along the diagonal and
shifting the contents.  The working representation is a square array of
integer values.  These are normalised to floats in the range (-1 1) at the
end of the process; the render function (`cl.parti.output`) will later
convert these values to colours.

"
      :author "andrew@acooke.org"}
  cl.parti.square
  (:use (cl.parti random mosaic))
  (:use clojure.math.numeric-tower))


;; ## Random parameters

(def ^:private
  ^{:doc "Range over which values can be shifted in a single transformation."}
  DELTA 127)

(defn- rand-two-points
  "Generate two values, `r1` and `r2`, selecting the first from a uniform
  distribution in the range [0 n) and the second in the range [0 (n-r1)).
  This means that `r1` and `r1+r2` are both in [0 n)."
  [n state]
  (let [[r1 state] (rand-byte n state)
        [r2 state] (rand-byte (- n r1) state)]
    [r1 r2 state]))

(defn- corners
  "These values generated above are used to select a square along the diagonal
  of the mosaic.  The length of the side of the square is taked from `r1`
  above; its offset is taken from `r2`.

  `diag` is 1 or -1 and defines the diagonal for the mosaic.
  `n` is the size of the mosaic (the number of tiles along one side)."
  [n diag side xlo]
  (let [m (dec n)
        xhi (+ xlo side)
        [ylo yhi] (if (> 0 diag) [xlo xhi] [(- m xhi) (- m xlo)])]
    [xlo xhi ylo yhi]))

(defn- rand-range
  "Generate a uniformly distributed pseudo-random integer in the range
  [-DELTA DELTA].

  This value is used to give the strength of the shift applied to the
  randomly selected square."
  [state]
  (let [[r state] (rand-byte (inc (* 2 DELTA)) state)]
    [(- r DELTA) state]))

(defn- parameters
  "Construct a lazy sequence of random values, taken from the functions
  above.  This provides the data for an arbitrary number of transformations.

  `state` is available at each step so that the latest state can be
  returned to the called once the desired number of transformations have
  been made."
  [n state]
  (lazy-seq
    (let [[r1 r2 state] (rand-two-points n state)
          [delta state] (rand-range state)]
      (cons [delta [r1 r2] state] (parameters n state)))))

;; ## The transformation

(def ^:private
  ^{:doc "Scale for converting for normalisation.  Smaller values emphasise
  middle ranges in the data."}
  NORM 0.3)

(defn- apply-2
  "Apply function `f` to the value in the nested 2D sequence `rows` at
  (`x`,`y`)."
  [f rows [x y]]
  (let [row (rows x)
        val (f (row y))]
    (assoc rows x (assoc row y val))))

; apply a function to all tiles within the square
(defn- transform-square
  "Add `delta` to the square defined by `r1` and `r2`.

  Again, the latest `state` is made available for use by the caller."
  [[n diag rows] [delta [r1 r2] state]]
  (let [[xlo xhi ylo yhi] (corners n diag r1 r2)
        xys (for [x (range xlo (inc xhi)) y (range ylo (inc yhi))] [x y])
        delta #(+ delta %)]
    [n diag (reduce #(apply-2 delta %1 %2) rows xys) state]))

(defn- repeated-transform
  "Pull all the above together - generate a sequence of random parameters
  and then iterate over them, repeatedly transforming the mosaic.

  Returns the final mosaic (nested 2D sequence of un-normalized floats)
  and the latest state."
  [n count state]
  (let [rows (vec (repeat n (vec (repeat n 0))))
        [diag state] (rand-sign state)
        [n d r s]
        (reduce transform-square [n diag rows]
          (take count
            (parameters n state)))]
    [r s]))

(defn square
  "The render function.  The output from `repeated-tranform` is normalized
  to the range (-1 1).

  Some parameters are inferred from the mosaic size, `n`, to give a
  consistent appearance across a range of sizes.

  All calculations before normalisation are exact (integer) values.  This
  should support alternative implementations (repeated application of
  transformations based on random *real* values could have been sensitive
  to small differences in floating point calculations)."
  [n]
  (fn [state]
    (let [[rows state] (repeated-transform n (expt n 2) state)
          norm (* NORM DELTA (expt n 0.8))]
      [(normalize norm rows) state])))

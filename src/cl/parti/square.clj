(ns ^{:doc "

The main image builder, responsible for generating the image structure.

To work well the end result must be attractive, but detailed.  The algorithm
here grew through iterative improvement and experimentation, but in
retrospect the following properties are important:

- **Diagonal symmetry.**  A completely random image feels 'messy' and is
  difficult to remember when making comparisons.

- **Structure over a range of scales.**  The largest scales give the image a
  particular character; smaller scales help carry more information in a
  detailed comparison.

- **Irregularity.** A 'structured' design - the idea that the image is
  structured becomes more important than the details of the structure.
  This is hard to explain, but easy to see in images from the `fourier`
  builder, where all the images are 'tartan-like' and become easy to
  confuse.

- **Tiles.**  These serve two purposes.  First, they allow more accurate
  comparison in the variation of tone between images (whether an area of
  similar colours is flat or varying).  Second, they give the impression
  of a 'computer generated', qualitative object (something like a barcode).

- **Saturated colours.**  These give a 'jewel-like' feel and help separate
  the image from a variety of contexts.

More than all the above, the end result must 'feel right'.  This is an
aristic, emotional choice, that is hard to define but critical in
attracting the attention of users.  Without this, a hex string is a
better format for the hash.

Images are generated by selecting random squares along the diagonal and
shifting the contents.  The working representation is a square array of
integer values.  These are normalised to floats in the range (-1 1) at the
end of the process; the render function (`cl.parti.output`) will later
convert these values to colours.

"
      :author "andrew@acooke.org"}
  cl.parti.square
  (:use (cl.parti random mosaic))
  (:use clojure.math.numeric-tower))


;; ## Random parameters

(def ^:private
  ^{:doc "Range over which values can be shifted in a single transformation."}
  DELTA 127)

(defn- rand-two-points
  "Generate two values, `side` and `offset`, selecting the first from a uniform
  distribution in the range [0 n) and the second in the range [0 (n-side)).
  This means that `side` and `side+offset` are both in [0 n).

  The value of `side` is then incremented by 1 to give a non-zero square,
  which `offset` will position on the diagonal."
  [n state]
  (let [[side state] (rand-byte n state)
        [offset state] (rand-byte (- n side) state)]
    [(inc side) offset state]))

(defn- rand-range
  "Generate a uniformly distributed pseudo-random integer in the range
  [-DELTA DELTA].

  This value is used to give the strength of the shift applied to the
  randomly selected square."
  [state]
  (let [[r state] (rand-byte (inc (* 2 DELTA)) state)]
    [(- r DELTA) state]))

(defn- parameters
  "Construct a lazy sequence of random values, taken from the functions
  above.  This provides the data for an arbitrary number of transformations.

  `state` is available at each step so that the latest state can be
  returned to the called once the desired number of transformations have
  been made."
  [n state]
  (lazy-seq
    (let [[side offset state] (rand-two-points n state)
          [delta state] (rand-range state)]
      (cons [delta side offset state] (parameters n state)))))

;; ## The transformation

(def ^:private
  ^{:doc "Scale for converting for normalisation.  Smaller values emphasise
  middle ranges in the data."}
  NORM 0.3)

(defn- apply-2
  "Apply function `f` to the value in the 2D nested sequences `rows` at
  (`x`,`y`)."
  [f rows [x y]]
  (let [row (rows x)
        val (f (row y))]
    (assoc rows x (assoc row y val))))

; apply a function to all tiles within the square
(defn- transform-square
  "Add `delta` to the square defined by `side` and `offset`.

  Again, the latest `state` is made available for use by the caller."
  [[n rows] [delta side offset state]]
  (let [xys (for [x (range side) y (range side)] [(+ x offset) (+ y offset)])
        delta #(+ delta %)]
    [n (reduce #(apply-2 delta %1 %2) rows xys) state]))

(defn- repeated-transform
  "Pull all the above together - generate a sequence of random parameters
  and then iterate over them, repeatedly transforming the mosaic.

  Returns the final mosaic (2D nested sequences of un-normalized integers)
  and the latest state."
  [n count state]
  (let [rows (vec (repeat n (vec (repeat n 0))))
        [n rows state]
        (reduce transform-square [n rows]
          (take count
            (parameters n state)))]
    [rows state]))

(defn square
  "The render function.  The output from `repeated-transform` is normalized
  to the range (-1 1).

  Some parameters are inferred from the mosaic size, `n`, to give a
  consistent appearance across a range of sizes.

  All calculations before normalisation are exact (integer) values.  This
  should support alternative implementations (repeated application of
  transformations based on random *real* values could have been sensitive
  to small differences in floating point calculations)."
  [n]
  (fn [state]
    (let [[rows state] (repeated-transform n (expt n 2) state)
          norm (* NORM DELTA (expt n 0.8))]
      [(normalize norm rows) state])))
